## 第一、ISO8583的规范中没用的域：
第一个域是bitMap
> 5-6 、8-10 、16、19-21、23-24、26-31、34、40、45-46、51、55-63、65-69
> 71-73、82、84、92-93、96、98、104-122、124-127

### 8583报文结构：
> 8583报文大部分情况下用在POS终端与后台收单系统的数据交换, 一般情况下(请注意这里的用词)  
> 一段完整的交易报文由以下几个部分组成:  
> 长度【总长度，即"报文头"+"数据"部分的长度】  +　报文头　+  数据(8583报文内容)



### 长度、报文头、数据

- 长度      
            

> 两个字节        表示报文的总长度(即"报文头"+"数据"部分的长度)   两种计算方法


- 报文头  
      
> 未知字节           ASCII或者BCD表示  
> 报文头[TPDU]为5个字节构成如下：类型ID[1个字节] + 源设备地址[2个字节] + 目的设备地址[2个字节]


- 数据  

128               具体报文数据
数据 报文内容由三部分按照以下顺序组成：消息类型标识 +  位图 + 数据元素
####消息类型标识MTI  FORMAT:N4, NUM
> N4表示BCD格式的时候由四个数字组成.
> 每个消息类型标识时报文内容得头.占用四个数字,在打包时用压缩得BCD码.向外传输
> MTI有两部分组成： 一个数字版本编号和三个数字消息标识


<pre>
位图位置：－ 
　　格式：定长 
　　类型：N4 
　　描述： 
　　数据包的第一部分，定义数据包的类型。 
　　数据类型由数据包的发起者设定，应遵循以下要求： 
　　数据包开始部分必须是信息类型； 
　　对不支持的信息类型能给出拒绝应答。 
　　0100授权交易 
　　0110授权交易答复 
　　0200金融交易 
　　0210金融交易答复 
　　0240查询交易 
　　0250查询交易答复 
　　0400冲正交易 
　　0410冲正交易答复 
　　0800管理交易 
　　0810管理交易答复
</pre>


#### 位图 
> 位图是8583包的灵魂，它是打包解包确定字段域的关键，而了解每个字段域的属性则是填写数据的基础，在此中用8个字节(1个字节为8位,则为8*8=64)
> 设置其后64位的域.8583通过检查位图中的1的位置可以确定其后的数据的域,然后根据域中规定的长度来取数据,这样解包就很方便了,打包则为相反.
> 首先检查域中有无数据,如有,则在相应的位图中的位置放置1,来标识此域中有数据打包与解包

<pre>
位图位置：1     -------也就是位图占第一个域。
格式：定长 
类型：B16（16进制16个字节,十六进制转换为二进制，一字节是8位，转化为二进制后总位数：16*8=128bit） 
描述： 
如将位图的第一位设为'1'，表示使用扩展位图（128个域），否则表示只使用基本位图（64个域）。 
如使用某数据域，应在位图中将相应的位设位'1'，如使用41域，需将位图的41位设为'1'。 
选用条件：如使用65到128域，需设位图域第一位为'1'
</pre>


#### 每个域的定义如下： 
```c++
　　typedef struct ISO8583 
　　{ 
　　　　int　　 bit_flag;　　　　　 /*域数据类型0 -- string, 1 -- int, 2 -- binary*/ 
　　　　char　　*data_name;　　　　 /*域名*/ 
　　　　int　　 length;　　　　　　 /*数据域长度*/ 
　　　　int　　 length_in_byte;　　 /*实际长度（如果是变长）*/ 
　　　　int　　 variable_flag;　　　/*是否变长标志0：否 2：2位变长, 3：3位变长*/ 
　　　　int　　 datatype;　　　　　　/*0 -- string, 1 -- int, 2 -- binary*/ 
　　　　char　　*data;　　　　　　　/*存放具体值*/ 
　　　　int　　 attribute;　　　　　/*保留*/ 
　　} 
```

128个域数据类型都是0
至于datatype则有的不一样

```c++　　　　
ISO8583 Tbl8583[128] = 
　　{ 
　　　　/* FLD 01 */ {0,"BIT MAP,EXTENDED", 8, 0, 0, 2, NULL,0}, 
　　　　/* FLD 02 */ {0,"PRIMARY ACCOUNT NUMBER", 22, 0, 2, 0, NULL,0}, 
　　　　/* FLD 03 */ {0,"PROCESSING CODE", 6, 0, 0, 0, NULL,0}, 
　　　　/* FLD 04 */ {0,"AMOUNT, TRANSACTION", 12, 0, 0, 1, NULL,0}, 
　　　　/* FLD 05 */ {0,"NO USE", 12, 0, 0, 0, NULL,0}, 
      .....
      }
```      
      
<pre>
变长，定长域说明 
　　如第二域：域名为主帐号， 
　　数据类型为string 
　　长度为22（是长长度不得超过此数） 
　　是个２位变长域 
　　由于是２位变长，在打包时需在数据域前加上数据的实际长度，如为19位，则表示为： 
　　19＋数据值（即前两位为长度）

　　如第三域：域名为处理码， 
　　数据类型为string 
　　长度为６ 
　　是个定长域 
　　必须填满６位。 
</pre>


### 实际例子
直接给出如下报文内容[实际就是除了以上长度、报文头之后的数据部分] 里面每一项由两个数字组成都是十六进制，其实就是一个字节，一个字节是八位，所以转换为二进制需要补位：
> "02 00 70 20 00 00 20 C0 82 00 19 06 20 51 32 00 00 00 02 61 20 60 00 00 00 
> 00 00 02 00 00 00 00 73 37 06 20 51 32 00 00 00 02 61 20 d1 91 12 01 00 00 00
>  00 00 30 30 30 30 31 31 31 31 31 30 32 32 35 30 31 35 33 31 31 31 31 31 31 01 
>  56 00 44 9f 26 08 92 b6 ae 9a 9b 10 2e d6 9f 27 01 80 9f 10 13 07 01 01 03 a0 a0 
>  10 01 0a 01 00 00 00 10 37 51 3a 22 be"

这是一串实际传输的报文, 上面显示的是这些数据的16进制. 你准备好了吗， 我要开始分析了.

#### 02 00
<pre>
这个是信息类型(MTI), 是一个四位的数字, 这里为"0200", 传输时用BCD表示即为"02h,00h"(如果用ASCII呢？看看上面的内容). 这个四位数字，每一位都有它的意义,
第一位:iso 8583 version number.   FROMAT:N1  表示只有一个数字
第二位:message class
第三位:message sub-class
第四位:transaction originator
就不翻译了，毕竟本来就是老外的东西, 自己理解吧.
0200表示为金融交易类型，至于这四位拆开不做细节了解。


结论：
1）根据数据长度确定读取几个字节，长度是20，读取10个字节，长度是3读取两个字节，以此类推。
2）根据倒数第三个数字确定数据类型是字符串、数字还是二进制
a.如果是数字，那么把读取到的字节内容全部当做实际数字
   如果是定长的数字，那么与域长度是几，那么就读取几/2个字节。如果与长度是3，读取2个字节，长度是6读取3个字节。
b.如果是字符串，那么把读取到的字节内容全部当做字符串。
   如果是变长字符串，那么先要读取第一位字节当做数字，数字是几就表示接下来还要继续读取多少/2个字节，比如第一个数字是37，表示接下来还要读取19个字节的字符串。
   如果是定长字符串，那么与域长度是几，就读取几个字节，比如域长度是13，就读取13个字节。
c.如果是二进制，那么把读取到的字节内容全部当做十六进制，然后转换为二进制，二进制*8就是具体位数。
</pre>




#### 70 20 00 00 20 C0 82 00
> bit map域, 指示哪些域存在, 容易计算出, 下面几个域存在:2, 3, 4, 11, 35, 41, 42, 49, 55.
> 解析：这个过程得将16进制数据转换为十进制，再由10进制转换为2进制
> 如16进制70转换为十进制112，十进制112转换为二进制1110000，1个字节8位，不够前面补0，所以最终结果是01110000
> 那么第2、3、4位都是1，所以这存在这几个域
> 因为位图第一位是0，所以使用基本位图（64个域）


#### 19 06 20 51 32 00 00 00 02 61 20
> /* FLD 2 */ {0,"PRIMARY ACCOUNT NUMBER ", 22, 0, 2, 0, NULL,0},  
> 从这个域的定义描述看，倒数第三个数字0表示数据类型是字符串，数据域长度是22，也就是11个字节。
> 倒数第四个数字2表示变长两位，所以这个域实际长度是20,第一个字节19表示账号长度为19，因为实际长度是20，所以用0补在前面。
> field 2, 账号, n..19, LLVAR, 一字节表示长度(19), 账号是19位, 前面补0后, 用10字节BCD表示.

#### 60 00 00
> /* FLD 3 */ {0,"PROCESSING CODE ", 6, 0, 0, 0, NULL,0},  
> 这里倒数第三个数字0表示数据类型是字符串，倒数第四个数字是0，表示不变长，就是定长。也就是实际长度就是6.也就是三个字节。
> field 3, 处理码, n6, 定长, 用3字节BCD表示
 
#### 00 00 00 02 00 00
> /* FLD 4 */ {0,"AMOUNT, TRANSACTION ", 12, 0, 0, 1, NULL,0},  
> 这里倒数第三个字节是1表示数据类型是数字，倒数第四个数字是0表示不变长，就是定长。也就是实际长度是12的数字.也就是6个字节。
> field 4, 交易金额, n12, 定长, 用6字节BCD表示, 这里的金额是200.00元.由于是金额，默认带两个小数点，所以前面的0不要。如果是编号前面的0得要。
 
#### 00 00 73
> /* FLD 11 */ {0,"SYSTEM TRACE AUDIT NUMBER ", 6, 0, 0, 1, NULL,0},  
> 这里倒数第三个数字是1表示数据类型是数字，倒数第四个是0，表示是不变长，定长。也就是实际长度是6的数字，也就是三个字节。
> field 11, 流水号, n6, 定长, 用3字节BCD表示.流水号为"000073".
 
#### 37 06 20 51 32 00 00 00 02 61 20 d1 91 12 01 00 00 00 00 00  
> /* FLD 35 */ {0,"TRACK 2 DATA ", 37, 0, 2, 0, NULL,0},  
> 这里倒数第三个数字是0表示数据类型是字符串，倒数第四个数字是2，表示变长两位。由于变长两位，所以第一个字节表示字符串长度.
> 取出完这第一个字节长度是37表示，表示接下来还有19个字节需要读取
> field 35, 二磁道数据, z..35, LLVAR, 一字节表示长度(37), 后面是19字节BCD表示的磁道数据
 
#### 30 30 30 30 31 31 31 31
> /* FLD 41 */ {0,"CARD ACCEPTOR TERMINAL ID. ", 8, 0, 0, 0, NULL,0},  
> 这里倒数第三个数字是0表示数据类型是字符串，倒数第四个数字是0表示不变长，定长。直接读取8个字节当做字符串。
> field 41, 终端号, ans8, 定长, ASCII表示, 这里终端号为"00001111"
 
#### 31 30 32 32 35 30 31 35 33 31 31 31 31 31 31  
> /* FLD 42 */ {0,"CARD ACCEPTOR IDENTIFICATION CODE ", 15, 0, 0, 0, NULL,0},  
> 这里倒数第三个数字是0表示数据类型是字符串，倒数第四个数字是0表示不变长，定长。直接读取15个字节当做字符串。
> field 42, 商户号, ans15, 定长, ASCII表示, 这里商户号为"102250153111111"
 
#### 01 56
> /* FLD 49 */ {0,"CURRENCY CODE,TRANSACTION ", 3, 0, 0, 0, NULL,0},  
> 这里倒数第三个数字是0表示数据类型是字符串，倒数第四个数字是0表示不变长，定长。直接读取3个字节当做字符串。
> field 49, 货币代码, n3, 定长, 前面补0后，用两字节BCD表示, 这里货币代码为"156"
 
#### 00 44 9f 26 08 92 b6 ae 9a 9b 10 2e d6 9f 27 01 80 9f 10 13 07 01 01 03 a0 a0 10 01 0a 01 00 00 00 10 37 51 3a 22 be
> /* FLD 55 */ {0,"NO USE", 999, 0, 3, 0, NULL,0},   
> 这里倒数第三个数字是0表示数据类型是字符串，倒数第四个数字是3表示变长三位，先读取前两个字节获取后面字符串当度.
> field 55, 这是IC卡交易的相关数据, 最大长度是255, 这一域用的IC卡数据一般在PBOC/EMV规范里
> 都有自己的定义(包括格式), 所以，一般在报文里的格式跟它们在PBOC/EMV里定义的一致.一般是TLV(tag+lenght+value)表示一个数据.简单介绍一下数据的意义.
> 
> "00 44":长度, 表示44个字节  

> "9f 26 08 92 b6 ae 9a 9b 10 2e d6":应用密文(application cryptogram), TLV, b8  
> 
> "9f 27 01 80":密文信息数据(cryptogram information data), TLV, b1  
> 
> "9f 10 13 07 01 01 03 a0 a0 10 01 0a 01 00 00 00 10 37 51 3a 22 be":  
> 
> 发卡行应用数据(issuer application data), TLV, 变长，最大32字节. b..32.  


ASCII表示，BCD表示，TLV



## 第二、银联的规范中没用的域：
> 1、8、17、20、21、24、27、29-31、34、40、46、47、56、64-69、71-89、
> 91-95、97-99、101、104-120、124-127


## 第三、JPOS CMF规范的没用的域：
> 1、9、16、19、20、27-29、31、34、36、40、44、47、48、51、57、58、60-62
> 64-67、69-71、73、74-96、98、99、104-110、114-128
